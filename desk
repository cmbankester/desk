#!/usr/bin/env bash
# vim: set filetype=sh:

PREFIX="${DESK_DIR:-$HOME/.desk}"
DESKS="${DESK_DESKS_DIR:-$PREFIX/desks}"


## Commands

cmd_version() {
    echo "â—²  desk 0.3.1"
}


cmd_usage() {
    cmd_version
    echo
    cat <<_EOF
Usage:

    $PROGRAM
        List the current desk and any associated aliases. If no desk
        is being used, display available desks.
    $PROGRAM init
        Initialize desk configuration.
    $PROGRAM (list|ls)
        List all desks along with a description.
    $PROGRAM (.|go) desk-name
        Activate a desk.
    $PROGRAM edit [desk-name]
        Edit (or create) a deskfile with the name specified, otherwise
        edit the active deskfile.
    $PROGRAM help
        Show this text.
    $PROGRAM version
        Show version information.

Since desk spawns a shell, to deactivate and "pop" out a desk, you
simply need to exit or otherwise end the current shell process.
_EOF
}

cmd_init() {
    if [ -d "$PREFIX" ]; then
        echo "Desk dir already exists at ${PREFIX}"
        exit 1
    fi
    read -p "Where do you want to store your deskfiles? (default: ${PREFIX}): " \
        NEW_PREFIX
    [ -z "${NEW_PREFIX}" ] && NEW_PREFIX="$PREFIX"

    if [ ! -d "${NEW_PREFIX}" ]; then
        echo "${NEW_PREFIX} doesn't exist, attempting to create."
        mkdir -p "$NEW_PREFIX/desks"
    fi

    local SHELLTYPE=$(get_running_shell)

    case "${SHELLTYPE}" in
        bash)   local SHELLRC="${HOME}/.bashrc" ;;
        fish)   local SHELLRC="${HOME}/.config/fish/config.fish" ;;
        zsh)    local SHELLRC="${HOME}/.zshrc" ;;
    esac

    read -p "Where's your shell rc file? (default: ${SHELLRC}): " \
        USER_SHELLRC
    [ -z "${USER_SHELLRC}" ] && USER_SHELLRC="$SHELLRC"
    if [ ! -f "$USER_SHELLRC" ]; then
        echo "${USER_SHELLRC} doesn't exist"
        exit 1
    fi

    echo "# Hook for desk activation" >> "$USER_SHELLRC"

    # Since the hook is appended to the rc file, its exit status becomes
    # the exit status of `source $USER_SHELLRC` which typically
    # indicates if something went wrong. If $DESK_ENV is void, `test`
    # sets exit status to 1. That, however, is part of desk's normal
    # operation, so we clear exit status after that.
    if [ "$SHELLTYPE" == "fish" ]; then
      echo "test -n \"\$DESK_ENV\"; and . \"\$DESK_ENV\"; or true" >> "$USER_SHELLRC"
    else
      echo "[ -n \"\$DESK_ENV\" ] && source \"\$DESK_ENV\" || true" >> "$USER_SHELLRC"
    fi

    echo "Done. Start adding desks to ${NEW_PREFIX}/desks!"
}


cmd_go() {
    local TODESK="$1"
    local DESKEXT=$(get_deskfile_extension)
    local DESKPATH="$(find "${DESKS}/" -name "${TODESK}${DESKEXT}")"

    if [ -z "$DESKPATH" ]; then
        echo "Desk $TODESK (${TODESK}${DESKEXT}) not found in $DESKS"
        exit 1
    else
        local SHELL_EXEC="$(get_running_shell)"
        DESK_NAME="${TODESK}" DESK_ENV="${DESKPATH}" "${SHELL_EXEC}"
    fi
}


cmd_list() {
    usage() {
        echo "usage: desk list [options]"
        echo "	--only-names         List only the names of the desks"
        echo "	--only-descriptions  List only the descriptions of the desks"
        echo "	--machine-readable   Use ' - ' to separate names from descriptions"
        echo "	-h, --help           Display help"
        exit 1
    }
    if [ ! -d "${DESKS}/" ]; then
        [ "$1" = --help ] || [ "$1" = -h ] && printf "%s\n" "$(usage)"
        echo "No desk dir! Run 'desk init'."
        exit 1
    fi
    local SHOW_NAMES SHOW_DESCRIPTIONS DESKEXT name desc len out longest AUTO_ALIGN

    while [[ $# > 0 ]]; do # if any keys remain in $@
      case "$1" in
        --only-names) test "$SHOW_NAMES" != false && SHOW_DESCRIPTIONS=false && AUTO_ALIGN=false ;;
        --only-descriptions) test "$SHOW_DESCRIPTIONS" != false && SHOW_NAMES=false && AUTO_ALIGN=false ;;
        --machine-readable) AUTO_ALIGN=false ;;
        --help|-h) printf "%s\n" "$(usage)" && exit 1 ;;
      esac
      shift # remove a key from the front of $@
    done

    out=""
    [ "$AUTO_ALIGN" != false ] && out="NAME - DESCRIPTION"$'\n'

    DESKEXT=$(get_deskfile_extension)
    longest=0

    while read -d '' -r f; do
        if [[ "$SHOW_NAMES" = false ]]; then
          desc=$(echo_description "$f")
          out+="$desc"$'\n'
        elif [[ "$SHOW_DESCRIPTIONS" = false ]]; then
          name=$(basename "${f/${DESKEXT}//}")
          out+="$name"$'\n'
        else
          name=$(basename "${f/${DESKEXT}//}")
          desc=$(echo_description "$f")
          out+="$name - $desc"$'\n'
          len=${#name}
          (( len > longest )) && longest=$len
        fi
    done < <(find "${DESKS}/" -name "*${DESKEXT}" -print0)
    if [[ "$AUTO_ALIGN" != false ]]; then
      printf "%s" "$out" | awk -v padding="$longest" -F' - ' '{
        printf "%-*s %s\n", padding, $1, substr($0, index($0, " - ")+2, length($0))
      }'
    else
      printf "%s" "$out"
    fi
}

cmd_current() {
    local DESKPATH=$DESK_ENV
    local DESK_NAME=${DESKPATH##*/}
    local DESK_NAME=${DESK_NAME%.*}
    if [ -z "$DESKPATH" ]; then
        echo "No desk activated."
        echo ""
        cmd_list
        exit 2
    else
        echo "$DESK_NAME"
        echo_description "$DESKPATH"
        local CALLABLES=$(get_callables "$DESKPATH")

        [ -z "$CALLABLES" ] || echo ""

        for NAME in $CALLABLES; do
            # Last clause in the grep regexp accounts for fish functions.
            local DOCLINE=$(
                grep -B 1 -E \
                    "^(alias ${NAME}=|(function )?${NAME}( )?\()|function $NAME" "$DESKPATH" \
                    | grep "#")

            if [ -z "$DOCLINE" ]; then
                echo "  ${NAME}"
            else
                echo "  ${NAME} -" "${DOCLINE##\# }"
            fi
        done
    fi
}

cmd_edit() {
    if [ $# -eq 0 ]; then
        if [ "$DESK_NAME" == "" ]; then
            echo "No desk activated."
            exit 3
        fi
        local DESKNAME_TO_EDIT="$DESK_NAME"
    elif [ $# -eq 1 ]; then
        local DESKNAME_TO_EDIT="$1"
    else
        echo "Usage: ${PROGRAM} edit [desk-name]"
        exit 1
    fi

    local DESKEXT=$(get_deskfile_extension)
    local EDIT_PATH="${DESKS}/${DESKNAME_TO_EDIT}${DESKEXT}"

    ${EDITOR:-vi} "$EDIT_PATH"
}

## Utilities

FNAME_CHARS='[a-zA-Z0-9_-]'

# Echo the description of a desk. $1 is the deskfile.
echo_description() {
    local descline=$(grep -E "#\s+Description" "$1")
    echo "${descline##*Description: }"
}

# Echo a list of aliases and functions for a given desk
get_callables() {
    local DESKPATH=$1
    grep -E "^(alias |(function )?${FNAME_CHARS}+ ?\()|function $NAME" "$DESKPATH" \
        | sed 's/alias \([^= ]*\)=.*/\1/' \
        | sed -E "s/(function )?(${FNAME_CHARS}+) ?\(\).*/\2/" \
        | sed -E "s/function (${FNAME_CHARS}+).*/\1/"
}

get_running_shell() {
    # Echo the name of the parent shell via procfs, if we have it available.
    if [ -e /proc ]; then
        # Get cmdline procfile of the process running this script.
        local CMDLINE_FILE="/proc/$(grep PPid /proc/$$/status | cut -f2)/cmdline"

        if [ -f "$CMDLINE_FILE" ]; then
            # Strip out any verion that may be attached to the shell executable.
            # Strip leading dash for login shells.
            local CMDLINE_SHELL=$(sed -r -e 's/\x0.*//' -e 's/^-//' "$CMDLINE_FILE")
            basename "$CMDLINE_SHELL"
            exit
        fi
    fi

    # Fall back to $SHELL otherwise.
    basename "$SHELL"
    exit
}

# Echo the extension of recognized deskfiles (.fish for fish)
get_deskfile_extension() {
    if [ "$(get_running_shell)" == "fish" ]; then
        echo '.fish'
    else
        echo '.sh'
    fi
}


PROGRAM="${0##*/}"

case "$1" in
    init) shift;               cmd_init "$@" ;;
    help|--help) shift;        cmd_usage "$@" ;;
    version|--version) shift;  cmd_version "$@" ;;
    ls|list) shift;            cmd_list "$@" ;;
    go|.) shift;               cmd_go "$@" ;;
    edit) shift;               cmd_edit "$@" ;;
    *)                         cmd_current "$@" ;;
esac
exit 0
